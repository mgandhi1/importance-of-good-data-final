# -*- coding: utf-8 -*-
"""MP3 Importance of Good Data Final.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1jmDAd0AbQWbPxUQg02IRbsnmx8E98nZN
"""

## 1.A)
import numpy as np
import pandas as pd
import seaborn as sns
import math

import matplotlib.pyplot as plt
import matplotlib.patches as patches

## 1.B) 
sns.set()

## 1.C) 
from google.colab import drive
drive.mount("/content/drive")

## 1.C) Contd. 
data_raw = pd.read_csv(r"/content/drive/MyDrive/NFLRush.csv")

## 1.D) 
data_raw.head()
##display(data_raw)
##data_raw

## 1.E) 
data_raw.shape

## 1.F) 
data_raw.columns

## 2.A) 
data_raw.Yards
##data_raw.GameId
##data_raw.Yards
##data_raw.JerseyNumber
##data_raw.HomeTeamAbbr
##data_raw.VisitorTeamAbbr
##data_raw.PlayerCollegeName
##data_raw.GameWeather

## 2.B) 
data_raw[data_raw["PlayId"] == 20181115001638].value_counts()
## len(data_raw[data_raw["PlayId"] == 20181115001638])  (=22)
## 22 rows found; 11 home, 11 away

## shared values for all 22 rows; play data
## similar attributes/columns found are shared assets such as: 
##    HomeTeamAbbr, VisitorTeamAbbr, Week, Stadium, Location
##    StadiumType, Turf, GameWeather, Temperature, Humidity
##    WindSpeed, WindDirection

## these are shared attributes that are common among the game- 
## teams, setting, weather, field, time, characteristics, etc

## unique rows; player data
## similar attributes/columns found are shared assets such as: 
##    DisplayName (Name), NflId, JerseyNumber, PlayerHeight, 
##    PlayerWeight, PlayerBirthDate, PlayerCollegeName, 
##    Position, Dir, X, Y, S, A, Dis, Dir, Orientation

## these are unique attributes tht are unique, such as player 
## data, age, name, etc; as well as individual/unique stats 
## that are player specific, like position, speed, 
## acceleration, distance, and direction

##data_raw.value_counts()

## 2.C)
##data_raw[data_raw["DefendersInTheBox"] == 3.0].value_counts()

len(data_raw[data_raw["DefendersInTheBox"] == 3])
##print(pd.unique(data_raw["DefendersInTheBox" = 3.0]))  (BROKEN)
##data_raw[data_raw["DefendersInTheBox"] == 3.0].nunique()

## 2.C) Contd
len(data_raw[data_raw["DefendersInTheBox"] == 3]["PlayId"].unique())
##.shape 
## set, print lenset of Id

## 2.C) Contd

## (not correct, wrong method) len(data_raw["PlayId"].unique()) / 509762 * 100

len(data_raw[data_raw["DefendersInTheBox"] == 3]["PlayId"].unique()) / len(data_raw["PlayId"].unique()) * 100

## we find that there are 396 unique occurences during which there are 3 
## defenders in the box. Once we apply unique playID, we find that the 
## number of unique playIDs with 3 deffenders in the box is 18. This   
## value makes sense, as the number of players per play is 22 (22*18=396)

## porportion of all plays that have 3 DefendersInTheBox (%)

## It does not seem to be common to have only 3 DefendersInTheBox- 
## Only approx ~0.0777% of plays have 3 DefendersInTheBox, which is a very small number

## 2.D) 

##michael_thomas = (df["Display_Name"] = Michael Thomas) 
##df.loc[michael_thomas]
len(data_raw[data_raw["DisplayName"] == 'Michael Thomas']["GameId"].unique())

## 50 unique games during which a player named "Michael Thomas" played

## 2.E) 
## 2 unique IDs found
data_raw[data_raw["DisplayName"] == "Michael Thomas"].value_counts('NflId')

## 2.E) Contd

MT1 = data_raw.loc[data_raw['NflId'] == 2556370]
print(len(MT1.value_counts('GameId')))
MT2 = data_raw.loc[data_raw['NflId'] == 2535687]
print(len(MT2.value_counts('GameId')))

## there must be a duplicate/oerlap because there is 1 overlapping value 
##(50 games)
## for loop or other way
## unique vs value counts
## U: list like 
## VC: tables, extrapolate single text from there

## 2.E) Contd
## 2.F) New

data_raw[data_raw["DisplayName"] == "Michael Thomas"].groupby(["Season" , "NflId" , "GameId"])["PlayId"].count()
##data_raw[data_raw["DisplayName"] == "Michael Thomas"]
##.groupby(["NflId"]).value_count()

#2017: 2535687 (5) and 2556370 (16)
#2018: 2535687(14) and 2556370 (16)

## 2.G) 
print(data_raw.groupby(['Season'])['Stadium'].value_counts())
## (does not work) data_raw[data_raw["Stadium"] == "Gillette"].groupby(["GameId"])["Season"].count()

## 2.H) 
## How messy is the data?
## Wind direction: very messy...

print(data_raw["WindDirection"].unique())

## 2.H) Contd. (Experimentation)
print(data_raw["PlayDirection"].unique())
## Not messy, only L/R

## 2.H) Contd.
print(data_raw["Season"].unique())
## Not messy, only 2017 and 2018

## 2.H) Contd.
print(data_raw["Position"].unique())
## Not messy, but seems to be missing some data: 
## https://www.rookieroad.com/football/positions/position-abbreviations/

## 2.H) Contd.
print(data_raw["Turf"].unique())

## 2.H) Contd.
print(data_raw["GameWeather"].unique())
## Very messy, imprecise/vague

## 3.A) 
sns.distplot(data_raw['Yards'], kde=False)
## kde false/true 

## The distribution of values is quite skewed, a large proportion of 
## values are between 0 and 10

## There are more values with negative yard runs than I imagined  
## (x<0)

## 3.B) 
sns.boxplot(data_raw['Yards'])

## the groups of similarly numbered/unique values tend to be grouped 
## together. The boxplot adds representation for the outliers, which may 
## not necessarily be seen as well in the standard distplot. While the 
## boxplot does not seem to be immediately misleading, it may overrepresent 
## the most popular figures (the more normal datapoints).

## 3.C)
sns.distplot(data_raw['Y'], kde=False)
## this represents the distribution of y (short axis) player positions 
## across the field. The players tend to be more closely grouped together 
## at the center of the field, and as such, there appears a large 
## majority of the players at the center (~20-30) of the plot.

## 3.C) Contd.  (Experimentation)
sns.distplot(data_raw['Humidity'], kde=False)

## 3.C) Contd. (Experimentation)
sns.distplot(data_raw['A'], kde=False)

## 3.D) 
sns.scatterplot(data=data_raw, x="YardLine", y="Yards")

## X+Y=100 because there are only 100Yds on a given field

## X is Yard line (where players are located) and Y is the yards ran 
## So, X (Yds) + Y (Yds ran) = 100 for the uppermost values

## Those given points along that diagonal line therefore represent 
## touchdowns, which complete 100Yds

## 3.E) 
sns.boxplot(data=data_raw, x="Season", y="Humidity")

# we can gather that the values occured between 40 and 80 for each season,
# while the average tends to increase slightly in 2018 as opposed to 2017

## 3.F) 
##sns.set_context("paper")
##sns.set_style("white")
sns.violinplot(data=data_raw, x="Season", y="Humidity", inner="quartile")

## The true values and weights are more visible in the violin plot 
## presented here as opposed to the boxplot above. The specific amounts 
## and quantities of each are much more evident, and can be more 
## accurately portrayed.

## 3.G) Experimentation
print(data_raw["OffenseFormation"].unique())

## 3.G) Contd.
sns.violinplot(data=data_raw, x="OffenseFormation", y="Yards")

## 3.G Contd. 
print(data_raw["PlayerWeight"].unique())
##(Not *too* many unique values)

## 3.G Contd. 
sns.scatterplot(data=data_raw, x="PlayerWeight", y="Position")

## 3.G Contd. 
sns.scatterplot(data=data_raw, x="Yards", y="Position")

## (or violinplot with same variables)
##sns.violinplot(data=data_raw, x="Yards", y="Position")

## 3.G Contd. 
print(data_raw["Week"].unique())
## (data is fine)

## 3.G Contd. 
sns.scatterplot(data=data_raw, x="Yards", y="Week")

## or scatterplot 
## sns.violinplot(data=data_raw, y="Yards", x="Week")

## 3.G Contd. 
sns.violinplot(data=data_raw, y="Yards", x="Quarter")

## (Relationship between Yds and Qtr?)

## 3.H) 
sns.scatterplot(data=data_raw, x="Humidity", y="Yards", hue="Season")

## 3.I) 
sns.scatterplot(data=data_raw, x="Humidity", y="Yards")

## 3.I Contd
sns.scatterplot(data=data_raw, x="Stadium", y="Yards")

## 3.I Contd. 
## There seems to be a noteable relationship between both Humidity/Yds 
## and Stadium/Yds. While there is some confounding and mess in the data 
## displayed, the optimal humidity for maximum yardage seems to be 
## between approx. 40 and 80% humidity. An interesting gap can be noted 
## between ~1% and ~6% to 7% humidity, which can be attributed to a gap 
## in the dataset.(?) 

## However, with regards to the stadium/Yds plot, there 
## doesn't seem to be a relationship between both variables, or any 
## useful extrapolated values for that matter. While some stadiums on the 
## right side of the graph appear to have a smaller distribution overall, 
## this may not necessarily be the case. 

## It does not seem useful in this scenario to include in the model overal

##3.J

def create_football_field(linenumbers=True,
                          endzones=True,
                          highlight_line=False,
                          highlight_line_number=50,
                          highlighted_name='Line of Scrimmage',
                          fifty_is_los=False,
                          figsize=(12*2, 6.33*2)):
    rect = patches.Rectangle((0, 0), 120, 53.3, linewidth=0.1,
                             edgecolor='r', facecolor='darkgreen', zorder=0)

    fig, ax = plt.subplots(1, figsize=figsize)
    ax.add_patch(rect)

    plt.plot([10, 10, 10, 20, 20, 30, 30, 40, 40, 50, 50, 60, 60, 70, 70, 80,
              80, 90, 90, 100, 100, 110, 110, 120, 0, 0, 120, 120],
             [0, 0, 53.3, 53.3, 0, 0, 53.3, 53.3, 0, 0, 53.3, 53.3, 0, 0, 53.3,
              53.3, 0, 0, 53.3, 53.3, 0, 0, 53.3, 53.3, 53.3, 0, 0, 53.3],
             color='white')
    if fifty_is_los:
        plt.plot([60, 60], [0, 53.3], color='gold')
        plt.text(62, 50, '<- Player Yardline at Snap', color='gold')
    # Endzones
    if endzones:
        ez1 = patches.Rectangle((0, 0), 10, 53.3,
                                linewidth=0.1,
                                edgecolor='r',
                                facecolor='blue',
                                alpha=0.2,
                                zorder=0)
        ez2 = patches.Rectangle((110, 0), 120, 53.3,
                                linewidth=0.1,
                                edgecolor='r',
                                facecolor='blue',
                                alpha=0.2,
                                zorder=0)
        ax.add_patch(ez1)
        ax.add_patch(ez2)
    plt.xlim(0, 120)
    plt.ylim(-5, 58.3)
    plt.axis('off')
    if linenumbers:
        for x in range(20, 110, 10):
            numb = x
            if x > 50:
                numb = 120 - x
            plt.text(x, 5, str(numb - 10),
                     horizontalalignment='center',
                     fontsize=20,  # fontname='Arial',
                     color='white')
            plt.text(x - 0.95, 53.3 - 5, str(numb - 10),
                     horizontalalignment='center',
                     fontsize=20,  # fontname='Arial',
                     color='white', rotation=180)
    if endzones:
        hash_range = range(11, 110)
    else:
        hash_range = range(1, 120)

    for x in hash_range:
        ax.plot([x, x], [0.4, 0.7], color='white')
        ax.plot([x, x], [53.0, 52.5], color='white')
        ax.plot([x, x], [22.91, 23.57], color='white')
        ax.plot([x, x], [29.73, 30.39], color='white')

    if highlight_line:
        hl = highlight_line_number + 10
        plt.plot([hl, hl], [0, 53.3], color='yellow')
        plt.text(hl + 2, 50, '<- {}'.format(highlighted_name),
                 color='yellow')
    return fig, ax

def plot_play(play_id, train_df=data_raw):
    def get_dx_dy(angle, dist):
        cartesianAngleRadians = (450-angle)*math.pi/180.0
        dx = dist * math.cos(cartesianAngleRadians)
        dy = dist * math.sin(cartesianAngleRadians)
        return dx, dy

    fig, ax = create_football_field()
    train_df.query("PlayId == @play_id and Team == 'away'") \
        .plot(x='X', y='Y', kind='scatter', ax=ax, color='orange', s=50, legend='Away')
    train_df.query("PlayId == @play_id and Team == 'home'") \
        .plot(x='X', y='Y', kind='scatter', ax=ax, color='blue', s=50, legend='Home')
    train_df.query("PlayId == @play_id and NflIdRusher == NflId") \
        .plot(x='X', y='Y', kind='scatter', ax=ax, color='red', s=100, legend='Rusher')
    rusher_row = train_df.query("PlayId == @play_id and NflIdRusher == NflId")
    yards_covered = rusher_row["Yards"].values[0]

    x = rusher_row["X"].values[0]
    y = rusher_row["Y"].values[0]
    rusher_dir = rusher_row["Dir"].values[0]
    rusher_orientation = rusher_row["Orientation"].values[0]
    rusher_speed = rusher_row["S"].values[0]
    dx, dy = get_dx_dy(rusher_dir, rusher_speed)
    dx_o, dy_o = get_dx_dy(rusher_orientation, rusher_speed/2)

    ax.arrow(x, y, dx, dy, length_includes_head=True, width=0.3)
    ax.arrow(x, y, dx_o, dy_o, length_includes_head=True, width=0.3, color="yellow")
    plt.title(f'Play # {play_id} and yard gain is {yards_covered}', fontsize=20)
    plt.show()

## 3.H // (3.K actual)
## one calls the other 

## plot_play(play_id=20170907000118, train_df=data_raw)
plot_play(play_id=20181115001638, train_df=data_raw)

print("Crap In, Crap Out")

# /end/ #